<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" 世界的中心" />
  	<meta property="og:site_name" content="世界的中心" />
  	<meta property="og:url" content="https://sonemiyuki.cn/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     世界的中心
  </title>

    <meta name="description" content="教学楼的天台，是世界的中心。" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://sonemiyuki.cn/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://sonemiyuki.cn/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://sonemiyuki.cn/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
      
        <link href="https://sonemiyuki.cn/index.xml" rel="alternate" type="application/rss+xml" title="世界的中心" />
      
    
    <meta name="generator" content="Hugo 0.83.0" />

    <link rel="canonical" href="https://sonemiyuki.cn/" />

     
</head>
<body class="nav-closed">
<div id="particles-js"></div>
  


 <div class="site-wrapper">



<header class="main-header " style="background-image: url(https://sonemiyuki.cn/images/user.jpg)">


    

    <nav class="main-nav overlay clearfix">
        
            <a class="blog-logo" href="https://sonemiyuki.cn/"><img src="https://sonemiyuki.cn/images/user.png" alt="Blog Logo" /></a>
        
        
    </nav>
<div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">
              <a class="btn-bootstrap-2 title-scroll" href="#content">世界的中心</a>
          </h1>
          <h2 class="page-description">教学楼的天台，是世界的中心。</h2>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    
    
    
    
    
    

    <div class="extra-pagination inner">
        <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="https://sonemiyuki.cn/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 2 of 3</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/page/3/">Older Posts &rarr;</a>
	
</nav>

    </div>

    
        
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/java/">Java面经基础（含OO）</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="oo的优点和三个特性">OO的优点和三个特性</h3>
<p>优点：基于面向过程，易于复用，易于理解，可扩展，可维护</p>
<ul>
<li>封装
<ul>
<li>外部不关心也无法修改内部实现</li>
</ul>
</li>
<li>继承
<ul>
<li>继承基类的方法并做出改变</li>
</ul>
</li>
<li>多态
<ul>
<li>同一个方法，不同的实现</li>
</ul>
</li>
</ul>
<h3 id="java编译过程">Java编译过程</h3>
<ol>
<li>编译：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。
编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的字面量（文本字符串、八种基本类型的值、被声明为final的常量等）以及符号引用（类和方法的全限定名、字段的名称和描述符、方法的名称和描述符）方法字节码中放的是各个方法的字节码（依赖操作数栈和局部变量表，由JVM解释执行）</li>
<li>经过JVM的解释运行
加载 &ndash;&gt; 验证 &ndash;&gt; 准备 &ndash;&gt; 解析 &ndash;&gt; 初始化（其中验证、准备、解析统称为类的连接）</li>
</ol>
<h3 id="jdk-jvm-jre">JDK JVM JRE</h3>
<p>注意JRE包含bin和lib，bin是JVM虚拟机，lib是映射到不同操作系统所需要的库。</p>
<h3 id="-和-equals">== 和 equals</h3>
<p>== 比较的是栈里面的值，基础数据类型比较基础数据类型，对象比较地址</p>
<p>equals默认用==进行比较
String的equals重写将另一个对象强转String</p>
<h3 id="final">final</h3>
<p>final的作用</p>
<ul>
<li>修饰类：类不能被继承</li>
<li>修饰方法：可以重载不能重写</li>
<li>修饰变量：常变量，不能更改值</li>
<li>修饰类变量：声明，非静态初始化块，构造器</li>
<li>类变量：静态初始化块，声明</li>
<li>作用在栈上，基础变量不能改，引用的值可变</li>
</ul>
<h3 id="为什么局部内部类和匿名内部类只能访问局部final类型的变量">为什么局部内部类和匿名内部类只能访问局部final类型的变量</h3>
<p>编译生成class文件，内部类的class文件会独立出来。外部类方法结束局部变量销毁，但是内部类如果还在执行就会出问题。将局部变量复制作为内部类的成员变量，延长其生命周期。</p>
<p>final是某种保持一致性的妥协</p>
<h3 id="重载和重写">重载和重写</h3>
<p>重载： 同一个类、方法名相同，参数名（类型、个数、顺序）不同，返回值修饰符可以不同；</p>
<p>重写：父子类中，方法名参数名必须相同，返回值范围和抛出异常值范围小于等于父类，修饰符范围大于等于父类，无法重写父类private方法。</p>
<h3 id="接口和抽象类">接口和抽象类</h3>
<ul>
<li>抽象类可以有普通成员函数，接口的方法必须全部抽象</li>
<li>抽象类成员变量类型比较宽，看接口的成员变量必须是public static final</li>
<li>抽象类单继承，可以通过接口实现多继承</li>
</ul>
<p>接口：对类的行为进行约束，约定了一定要有某个方法。like-a。</p>
<p>抽象类设计的本质是代码复用。需要不同的类具有某种相同的行为，还需要这些类的这些方法实现方法一致。is-a。</p>
<p>关注事物的本质用抽象类，关注某些操作用接口。</p>
<p>定义抽象类的代价比较高，定义接口可以降低设计难度。</p>
<p>抽象类被应用于模板方法中。</p>
<h2 id="hashcode-和-equals">hashCode 和 equals</h2>
<p>hashCode:获取哈希值，或者说将其map到int的范围内。</p>
<p>对象加入HashSet的时候，HashSet会先计算对象的HashCode判断对象加入的位置，看该位置是否还有值，若无，java假设对象没有重复出现，如果发现有，调用equals检查是否相同。核心在减少equals的次数</p>
<h2 id="default-关键字">default 关键字</h2>
<p>Java 8在增强集合的过程中引进了default关键字。让其支持lambda表达式的时候，就面临了这样的挑战。为了克服这个困难，Java 8中引入了一个新的概念，叫做default方法，也可以称为Defender方法，或者虚拟扩展方法（Virtual extension methods)。
Default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。
Default方法实现了对接口的扩展。
同名的default方法必须在扩展类中被重写。
Iterator接口的default方法是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">default</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;remove&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>如果不重写，默认Iterator无法使用Remove方法，反之，若重写，就代表支持。</p>
<h3 id="jdk-8-function接口">JDK 8 Function接口</h3>
<p>类似于数学上的函数，需要实现一个从泛型T到泛型R的函数映射，实现apply方法。</p>
<p>compose 和 andThen</p>
<p>compose括号里的before函数先走，然后是调用函数，然后是andThen括号里的after函数。</p>
<p><img src="https://sonemiyuki.cn/images/java/FunctionInterface.png" alt="compose 和 andThen"></p>
<h3 id="transient关键字">transient关键字</h3>
<p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。</p>
<h3 id="synchronized关键字">synchronized关键字</h3>
<p>synchronized锁什么？锁对象。</p>
<p>锁的对象包括：</p>
<ul>
<li>this</li>
<li>临界资源对象</li>
<li>Class 类对象。</li>
</ul>
<p>保证同一时刻最多只有1个线程执行 被Synchronized修饰的方法 / 代码</p>
<ul>
<li>修饰 实例方法 / 代码块时，（同步）保护的是同一个对象方法的调用 &amp; 当前实例对象</li>
<li>修饰 静态方法 / 代码块时，（同步）保护的是 静态方法的调用 &amp; class 类对象</li>
</ul>
<p>原理</p>
<ol>
<li>依赖JVM实现JVM等级的同步</li>
<li>底层通过一个monitor完成，wait，notify方法也依赖于monitor对象</li>
</ol>
<p>特点：原子性、可见性、有序性、可重入性、重量级</p>
<p>机理：</p>
<ol>
<li>维护锁的持有线程和持有数量</li>
<li>调用synchronized代码是检查对象是否被锁
<ol>
<li>是的话检查是否被当前线程锁定</li>
<li>不是的话假如等待队列，计数加1</li>
</ol>
</li>
<li>释放的时候计数减1</li>
<li>计数为0释放锁</li>
</ol>
<p>当锁定对象为this 时，相当于同步方法。</p>
<p>Java 中锁的种类大致分为</p>
<ul>
<li>偏向锁</li>
<li>自旋锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ul>
<p>因为 synchronized 无论是同步的方法还是同步的代码块，都会先把主内存的数据拷贝到工作内存中，同步代码块结束，会把工作内存中的数据更新到主内存中，这样主内存中的数据一定是最新的。更重要的是禁用了乱序重组以及保证了值对存储器的写入，这样就可以保证可见性。</p>
<p>缺点：</p>
<ul>
<li>等待线程无法控制</li>
<li>线程存在插队现象</li>
</ul>
<p>同步方法：</p>
<p>同步方法锁定的是当前对象。当多线程通过同一个对象引用多次调用当前同步方法时，需同步执行。
也就是说当一个线程访问同步方法时，其他线程访问这个方法将会被阻塞(等待锁)。</p>
<p>同步代码块：
用细粒度的同步增加效率。</p>
<ul>
<li>注意把IO语句移出同步块</li>
</ul>
<p>synchronized(非this对象 object)，这个对象如果是实例变量的话，指的是对象的引用，只要对象的引用不变，即使改变了对象的属性，运行结果依然是同步的。</p>
<p>锁的是堆内存中的对象，而不是引用。</p>
<p>synchronized 还可以应用在静态方法上，如果这么写，则代表的是对当前 .java 文件对应的 Class 类加锁。</p>
<p>发生异常自动释放锁</p>
<p>参考链接：
<a href="https://blog.csdn.net/super_YC/article/details/71439786">java 程序编译和运行过程详解</a>
<a href="https://blog.csdn.net/qq_41595139/article/details/108367464">Default关键字</a>
<a href="https://blog.csdn.net/wang_zqiang/article/details/86595735">Function接口简介</a>
<a href="https://blog.csdn.net/a1102325298/article/details/82595923">synchronized关键字</a>
<a href="https://www.jianshu.com/p/2ed498b43628">synchronized关键字2</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

    
        
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/java/">Java面经集合</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="stringstringbuilderstringbuffer">String、StringBuilder、StringBuffer</h3>
<p>String：final修饰，不可变，每次操作产生新对象，浪费时间空间</p>
<p>StringBuffer和StringBuilder在原对象进行操作。StringBuffer的所有方法都是synchronize方法修饰的。</p>
<p>性能 Builder &gt; Buffer &gt; String</p>
<p>场景：改变字符串内容
优先StringBuilder，多线程使用StringBuffer。</p>
<h3 id="list-和-set">List 和 Set</h3>
<p>List： 有序，可重复，允许多个null，可以用迭代器也可以用get方法访问元素</p>
<p>Set：无序，不可重复，最多允许一个null，只能用迭代器遍历。</p>
<p>HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的<strong>Map对象的key</strong>，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p>
<h3 id="arraylist-和-linkedlist">ArrayList 和 LinkedList</h3>
<p>ArrayList：本质上基于数组，适合下标访问，具有1.5倍扩容机制，尾插法移动少，性能提高好。</p>
<p>LinkedList：本质上基于链表时适合插入删除，不适合查询，必须用iterator遍历，否则时间复杂度过大。indexOf会遍历整个链表。</p>
<h3 id="hashmap-和-hashtable">HashMap 和 HashTable</h3>
<p>HashTable线程安全，所有方法synchronized修饰。HashMap允许null的key和value。</p>
<p>底层实现：数组+链表
数组：二次hash之后映射到一个数组上面那如果未冲突则直接存Node进去，如果冲突，equals判断，相同则取代钙元素，否则判断链表高度，链表高度达到8转为红黑树，低于6则转回链表。</p>
<h3 id="hashmap扩容">HashMap扩容</h3>
<p>capacity 即容量，默认16。loadFactor 加载因子，默认是0.75threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。</p>
<p>当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。</p>
<p>HashMap的容量变化通常存在以下几种情况：
空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数设置赋值给阈值（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 阈值 = 容量 * 负载因子 。（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。（容量和阈值都变为原来的2倍时，负载因子还是不变）</p>
<p>由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在原位置，要么在原长度+原位置的位置。数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标确定。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“原长度+原坐标”。在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。</p>
<p>参考链接：
<a href="https://blog.csdn.net/prairie97/article/details/78481493">java中Map和Set的底层分析</a>
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap扩容机制</a>
<a href="https://blog.csdn.net/qq_30711091/article/details/88847892">Java集合类</a>
<a href="https://blog.csdn.net/sl1992/article/details/100149187">Spliterator 1</a>
<a href="https://www.cnblogs.com/nevermorewang/p/9368431.html">Spliterator 2</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

    
        
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/get-post/">操作系统(1)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h2 id="1-操作系统概述">1. 操作系统概述</h2>
<ul>
<li>执行指令：Fetch -&gt; Execute</li>
</ul>
<p>四种中断：</p>
<ul>
<li>程序中断：由程序执行结果产生（溢出，除以零，非法机器指令，访问不合法/无权限内存）</li>
<li>时钟中断：处理器内部的计时器产生，允许操作系统以一定的规则执行函数</li>
<li>IO中断：由IO控制器产生，用于发信号通知操作是否正常完成及其错无条件</li>
<li>硬件失效中断：硬件故障产生的中断</li>
</ul>
<p>IO中断</p>
<ul>
<li>无中断：在写的时候直接写</li>
<li>短IO等待时间：处理器和IO并行，用中断处理器进程的方式处理IO的结束</li>
<li>长IO等待时间：等到下一个进程开始的时候对上一个进程的IO收尾，开始下一个IO的准备</li>
</ul>
<p>中断执行</p>
<ul>
<li>本质上是栈的思想和应用
<ul>
<li>设备控制器或者其他系统硬件产生一个中断</li>
<li>处理器结束指令执行</li>
<li>处理器发送中断应答信号</li>
<li>PSW，PC入栈</li>
<li>根据中断加载新的PC值</li>
<li>保存剩余的处理状态信息</li>
<li>处理终端</li>
<li>恢复状态信息</li>
<li>恢复PSW，PC</li>
</ul>
</li>
</ul>
<p>多中断</p>
<ul>
<li>嵌套中断（优先级）</li>
<li>顺序中断（默认）</li>
</ul>
<p>存储器的三大要素两两关系</p>
<ul>
<li>存储时间</li>
<li>位价格</li>
<li>总容量</li>
</ul>
<p>速度降低，时间变高，价格降低，容量变大</p>
<ul>
<li>寄存器</li>
<li>Cache</li>
<li>内存</li>
<li>磁盘</li>
<li>磁带</li>
</ul>
<p>设计Cache需要考虑的因素</p>
<ul>
<li>存储器大小</li>
<li>块的大小</li>
<li>mapping函数</li>
<li>替换算法</li>
<li>写策略</li>
<li>缓存级数</li>
</ul>
<p>DMA</p>
<ul>
<li>可编程IO操作：需要程序员监控检查，耗费资源</li>
<li>中断驱动IO操作：IO准备好之后会对处理器进行中断，每个字都要通过处理器</li>
<li>DMA操作：DMA模块直接和存储器操作，传输整个数据块，传输完成产生中断
<ul>
<li>停止访存、周期挪用、交替访存</li>
</ul>
</li>
</ul>
<p>习题：</p>
<ul>
<li>多终端的处理方式是什么？</li>
<li>什么是Cache？</li>
<li>多处理器和多核系统的区别？</li>
<li>时间局部性、空间局部性</li>
</ul>
<h2 id="进程描述和控制">进程描述和控制</h2>
<p>什么是进程？</p>
<ul>
<li>一个正在执行的程序</li>
<li>计算机中正在运行的程序的一个实例</li>
<li>一个具有如下要素的活动单元：一组指令序列的执行、一个当前状态、一组相关的系统资源的集合</li>
<li>代码、数据、PCB</li>
</ul>
<p>进程的属性与PCB的内容</p>
<ul>
<li>ID</li>
<li>状态</li>
<li>优先级</li>
<li>程序计数器</li>
<li>内存指针</li>
<li>上下文数据</li>
<li>IO状态信息</li>
<li>审计信息</li>
</ul>
<p>进程状态</p>
<ul>
<li>二状态模型</li>
<li>五状态模型</li>
<li>七状态模型</li>
</ul>
<p>进程创建的原因：</p>
<ul>
<li>新的批处理作业</li>
<li>用户登录</li>
<li>OS服务</li>
<li>派生进程</li>
</ul>
<p>进程终止的原因：</p>
<ul>
<li>正常完成</li>
<li>算术错误</li>
<li>数据误用</li>
<li>超过时限</li>
<li>时间超出</li>
<li>OS干预</li>
<li>内存不足</li>
<li>IO失败</li>
<li>父进程终止</li>
<li>父进程请求</li>
<li>越界</li>
<li>无效指令</li>
<li>保护错误</li>
<li>特权指令</li>
</ul>
<p>进程五状态图
<img src="https://sonemiyuki.cn/images/os/5statemodel.png" alt="进程五状态图"></p>
<p>为什么要把进程挂起</p>
<ul>
<li>在没有虚拟内存的情况下，进程必须载入内存才能运行</li>
<li>所有进程等待IO的时候处理器空闲</li>
<li>交换一些进程到磁盘以释放内存</li>
<li>阻塞变成挂起</li>
</ul>
<p>挂起进程的特点：</p>
<ul>
<li>被封印在磁盘中，不能立即执行</li>
<li>为了阻止进程执行可以将其挂起</li>
<li>必须由代理显式命令系统对其状态转换</li>
</ul>
<p>进程挂起的原因</p>
<ul>
<li>交换</li>
<li>其他OS原因</li>
<li>用户请求</li>
<li>定时进程</li>
<li>父进程请求</li>
</ul>
<p>OS是什么</p>
<p>OS本质上是管理系统资源的实体</p>
<ul>
<li>控制计算机系统的内部事件</li>
<li>为处理器执行任务进行调度和分配</li>
<li>给进程分配资源</li>
<li>响应用户程序的服务请求</li>
</ul>
<p>OS维护的信息</p>
<ul>
<li>内存表</li>
<li>IO表</li>
<li>文件表</li>
<li>进程表</li>
</ul>
<p>内存表：跟踪主存和辅存</p>
<ul>
<li>分配给进程的主存</li>
<li>分配给进程的辅存</li>
<li>主存或者虚存的保护属性</li>
<li>管理虚存需要的信息</li>
</ul>
<p>IO表：管理计算机设备的IO设备和通道</p>
<ul>
<li>IO设备的状态</li>
<li>IO操作的状态</li>
<li>IO传送的源地址和目的地址</li>
</ul>
<p>文件表：</p>
<ul>
<li>文件的存在性</li>
<li>文件在辅存中的位置</li>
<li>文件的当前状态</li>
<li>文件的属性</li>
<li>大部分信息由文件管理系统维护和使用</li>
</ul>
<p>进程表：OS用于控制和管理进程的表</p>
<ul>
<li>进程加载的位置</li>
<li>进程映像
<ul>
<li>用户程序</li>
<li>用户数据
<ul>
<li>程序数据</li>
<li>用户栈</li>
<li>可修改的程序</li>
</ul>
</li>
<li>系统栈</li>
<li>PCB</li>
</ul>
</li>
</ul>
<p>PCB本质上是进程属性的集合</p>
<ul>
<li>进程标识
<ul>
<li>ID号</li>
</ul>
</li>
<li>处理器状态信息
<ul>
<li>用户可见存储器</li>
<li>控制状态寄存器
<ul>
<li>PC</li>
<li>PSW</li>
</ul>
</li>
<li>栈指针
<ul>
<li>LIFO系统栈</li>
</ul>
</li>
</ul>
</li>
<li>进程控制信息
<ul>
<li>调度和状态信息
<ul>
<li>进程状态</li>
<li>优先级</li>
<li>调度信息</li>
<li>事件</li>
</ul>
</li>
<li>数据结构</li>
<li>进程间通信信息</li>
<li>进程特权
<ul>
<li>被赋予的特权</li>
<li>系统实用程序和服务使用</li>
</ul>
</li>
<li>存储管理</li>
<li>资源所有权和使用情况</li>
</ul>
</li>
</ul>
<p>PCB的作用</p>
<ul>
<li>进程调度</li>
<li>资源分配</li>
<li>中断处理</li>
<li>性能监控和分析</li>
</ul>
<p>访问PCB的方法</p>
<p>用ID访问</p>
<p>困难在于对PCB的保护，因此出现了处理例程对PCB进行仲裁与保护。</p>
<p>执行模式：</p>
<ul>
<li>用户模式</li>
<li>内核模式</li>
</ul>
<p>模式切换：PSW</p>
<p>进程创建：</p>
<ul>
<li>分配ID</li>
<li>分配空间</li>
<li>初始化PCB</li>
<li>设置连接</li>
<li>创建数据结构如审计文件</li>
</ul>
<p>进程切换时机：</p>
<ul>
<li>时钟中断
<ul>
<li>时间片</li>
</ul>
</li>
<li>IO中断
<ul>
<li>等IO</li>
<li>优先级抢占</li>
</ul>
</li>
<li>内存错误
<ul>
<li>虚存不在主存中</li>
<li>调入内存的IO请求</li>
<li>进程切换</li>
</ul>
</li>
<li>陷阱
<ul>
<li>一个错误或者异常</li>
<li>进程退出切换到别的进程执行</li>
</ul>
</li>
<li>系统调用
<ul>
<li>进程对OS发出系统调用服务</li>
</ul>
</li>
</ul>
<p>进程切换步骤：</p>
<ul>
<li>保存处理器上下文
<ul>
<li>PC和其他寄存器</li>
</ul>
</li>
<li>更新当前运行态的PCB
<ul>
<li>修改状态</li>
</ul>
</li>
<li>PCB移到相应队列</li>
<li>选择另一个进程执行</li>
<li>更新PCB，进程状态改成运行态</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器的上下文</li>
</ul>
<p>内核功能：</p>
<ul>
<li>进程管理
<ul>
<li>进程创建和终止</li>
<li>进程调度和委派</li>
<li>进程切换</li>
<li>进程同步和通信支持</li>
<li>管理PCB</li>
</ul>
</li>
<li>内存管理
<ul>
<li>为进程分配地址</li>
<li>交换</li>
<li>页管理和段管理</li>
</ul>
</li>
<li>IO管理
<ul>
<li>Buffer管理</li>
<li>为进程分配IO通道和设备</li>
</ul>
</li>
<li>支持功能
<ul>
<li>中断</li>
<li>记账</li>
<li>监视</li>
</ul>
</li>
</ul>
<p>OS的执行</p>
<ul>
<li>无进程内核
<ul>
<li>在所有的进程之外执行OS内核</li>
<li>OS代码在特权状态下工作的独立实体被实行</li>
<li>进程的概念仅适用于用户程序</li>
</ul>
</li>
<li>在用户进程中执行
<ul>
<li>OS软件在用户进程中</li>
<li>代码和数据是共享的</li>
<li>执行OS代码切换到内核模式</li>
<li>只进行进程内模式切换</li>
<li>在这基础上，用户无法篡改OS例程</li>
</ul>
</li>
<li>基于进程的OS
<ul>
<li>把OS当做一组系统进程实现</li>
<li>多处理器或者多机系统</li>
</ul>
</li>
</ul>
<p>UNIX进程状态</p>
<p><img src="https://sonemiyuki.cn/images/os/unixstatemodel.png" alt="UNIX进程状态"></p>
<p>习题：</p>
<p>为什么需要用户模式和内核模式？
操作系统新建进程的步骤是什么？
画出七状态模型的模型图并且解释状态变化的原因。</p>
<p>参考书籍：
操作系统————精髓与设计原理（第八版） William Stallings</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/os/">#os</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

    
        
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/get-post/">Jmeter(1)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h4 id="jmeter">Jmeter</h4>
<p>Jmeter脚本生成</p>
<ul>
<li>借助第三方工具录制
<ul>
<li>badboy 被淘汰</li>
<li>blazemeter 大陆无法注册账号</li>
</ul>
</li>
<li>使用自带的http代理服务器方式生成
<ul>
<li>添加线程&ndash;线程组</li>
<li>添加配置元件&ndash;cookie管理器</li>
<li>添加非测试元件&ndash;http代理服务器</li>
<li>配置http代理服务器并启动
<ul>
<li>端口：用户指定，和服务器无关</li>
<li>目标控制器：</li>
<li>Type：有时候需要选Java</li>
</ul>
</li>
<li>在客户端进行设置，使客户端请求通过代理。
<ul>
<li>Internet选项-连接-局域网设置</li>
</ul>
</li>
</ul>
</li>
<li>抓包手写</li>
</ul>
<p>Jmeter代理服务器</p>
<ul>
<li>转发</li>
<li>翻译</li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/jmeter/">#Jmeter</a>,
            
                <a href="https://sonemiyuki.cn/tags/http/">#http</a>,
            
                <a href="https://sonemiyuki.cn/tags/tester/">#tester</a>,
            
        
        <time class="post-date" datetime="2021-07-11T11:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

    
        
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/10/network/">性能测试Note（3）</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="基于loadrunner的性能测试note3">基于LoadRunner的性能测试Note（3）</h1>
<p>一小时内6000个用户开户</p>
<p>用lr事务手测单个用户时间，假设单次15s
一个小时一个vuser可以完成240个用户开户
6000/240=25，可用25个vuser模拟一小时内的6000个开户操作</p>
<p>unique number
start 1
block 240*1.2=288
7200个testcase
确定需求，分析约束，准备数据。</p>
<p>关联-参数化-检查点</p>
<p>参数化：客户端提交给服务端的参数
关联：服务端返回给客户端的参数</p>
<p>订购机票
open_index
submit_login
info_flight
find_flight
select_flight
pay_flight
sign_off</p>
<p>账户参数化：username, usersession做关联</p>
<p>出发和到达的城市需要随机化，随机某个具体航班</p>
<p>web_reg_save_param(&ldquo;fligts&rdquo;, &ldquo;LB=&quot;&gt;&rdquo;, &ldquo;RB=<!-- raw HTML omitted -->&rdquo;,&ldquo;ORD=All&rdquo;,LAST);
根据业务适当去重
strcmp</p>
<p>吞吐量，响应时间，系统资源&hellip;&hellip;</p>
<p>结果分析：根据Analysis进行结果分析</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/loadrunner/">#LoadRunner</a>,
            
                <a href="https://sonemiyuki.cn/tags/tester/">#tester</a>,
            
                <a href="https://sonemiyuki.cn/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">#性能测试</a>,
            
        
        <time class="post-date" datetime="2021-07-10T16:54:30&#43;08:00">
            10 Jul 2021
        </time>
    </footer>
</article>

    

    <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="https://sonemiyuki.cn/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 2 of 3</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/page/3/">Older Posts &rarr;</a>
	
</nav>


</main>

    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">世界的中心</a> All rights reserved - 2021-</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/index.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.min.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.js"></script>  

</body>
</html>

