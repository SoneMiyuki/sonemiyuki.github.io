<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Posts &middot;  世界的中心" />
  	<meta property="og:site_name" content="世界的中心" />
  	<meta property="og:url" content="https://sonemiyuki.cn/post/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Posts &middot;  世界的中心
  </title>

    <meta name="description" content="教学楼的天台，是世界的中心。" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://sonemiyuki.cn/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://sonemiyuki.cn/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://sonemiyuki.cn/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://sonemiyuki.cn/index.xml" rel="alternate" type="application/rss+xml" title="世界的中心" />
      
      
        <link href="https://sonemiyuki.cn/post/index.xml" rel="alternate" type="application/rss+xml" title="Posts &middot; 世界的中心" />
      
    
    <meta name="generator" content="Hugo 0.83.0" />

    <link rel="canonical" href="https://sonemiyuki.cn/post/" />

     
</head>
<body class="nav-closed">
<div id="particles-js"></div>
  


 <div class="site-wrapper">




	<header class="main-header" style="background-image: url(https://sonemiyuki.cn/images/user.jpg)">

    <nav class="main-nav overlay clearfix">
      
        <a class="blog-logo" href="https://sonemiyuki.cn/"><img src="https://sonemiyuki.cn/images/user.png" alt="Home" /></a>
      
      
        
          <a class="menu-button icon-feed" href="https://sonemiyuki.cn/post/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">世界的中心</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    
    
    
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 4</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/post/page/2/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/13/catalogue/">准备目录</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <ul>
<li>计算机网络</li>
<li>操作系统</li>
<li>Mysql数据库</li>
<li>Linux常用命令</li>
<li>Java后端框架</li>
<li>Java基础</li>
<li>Java集合类</li>
<li>Jmeter</li>
<li>数据结构</li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/catalogue/">#catalogue</a>,
            
        
        <time class="post-date" datetime="2021-07-13T16:58:30&#43;08:00">
            13 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/13/java/">数据结构常识</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="bst-二叉搜索树">BST 二叉搜索树</h3>
<p>左小右大，递归定义。
新插入的节点永远是叶子。</p>
<h3 id="平衡二叉树">平衡二叉树</h3>
<p>增加操作</p>
<ul>
<li>旋转
<ul>
<li>左左</li>
<li>右右</li>
</ul>
</li>
<li>双旋
<ul>
<li>左右</li>
<li>右左</li>
</ul>
</li>
</ul>
<p>删除操作</p>
<p>删根：补充比较高的树的节点，左补大，右补小</p>
<p>删树：递归下去查找</p>
<p>删除节点之后进行适当旋转</p>
<p>平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。如果某一结点的平衡因子绝对值大于1则说明此树不是平衡二叉树。为了方便计算每一结点的平衡因子我们可以为每个节点赋予height这一属性，表示此节点的高度。</p>
<p>ALV树适用于大量查询，少量插入和删除的场景中。</p>
<h3 id="红黑树r-b-tree">红黑树（R-B Tree）</h3>
<p>大量查询，大量插入和删除，现在使用ALV树就不太合适了，因为ALV树大量的插入和删除。适当牺牲平衡性换取增删的效率。</p>
<p>红黑树中，空节点也是树的一部分。</p>
<p>1）每个结点或红或黑
2）根结点是黑色
3）空叶子结点是黑色
4）如果一个结点是红色，那么它的子节点是黑色
5）从任意一个结点出发到他的后代的空的叶子结点经过的黑结点个数相同</p>
<p>任意结点到空的叶子结点的所有路径中，没有一条路径会大于其他路径的两倍</p>
<p>Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<p>旋转操作</p>
<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
<p>增加操作</p>
<p>先用平衡树的方式插入结点，将结点染红，通过旋转和重新着色使得其重新成为红黑树。</p>
<p>我们有必要重复一下五条性质</p>
<p>1）每个结点或红或黑
2）根结点是黑色
3）空叶子结点是黑色
4）如果一个结点是红色，那么它的子节点是黑色
5）从任意一个结点出发到他的后代的空的叶子结点经过的黑结点个数相同</p>
<p>新插入一个红结点，只会和性质4冲突。</p>
<p>新增的结点（红色）插入之后可能面临的几种情况，以及他们的处理措施</p>
<p>删除节点</p>
<ol>
<li>
<p>删除结点为红色</p>
<ol>
<li>直接删除</li>
</ol>
</li>
<li>
<p>删除结点为黑色，其兄弟结点没有儿子</p>
<ol>
<li>兄弟结点变红，父亲结点变黑，然后将父亲结点当作当前结点按照这几种情形处理，直到当前结点为根结点</li>
</ol>
</li>
<li>
<p>删除结点为黑色，其兄弟结点有一个孩子不空，并且该孩子和兄弟结点在同一边（同为左子树或者同为右子树）：</p>
<ol>
<li>不管是括号中那种情况，先交换兄弟结点和父亲结点的颜色，并且把父亲结点和兄弟结点的子结点涂成黑色</li>
<li>其他情况
<ol>
<li>如果兄弟结点和兄弟结点的儿子都在右子树的话：对父亲结点进行左旋</li>
<li>如果兄弟结点和兄弟结点的儿子都在左子树的话：对父亲结点进行右旋</li>
</ol>
</li>
</ol>
</li>
<li>
<p>删除结点为黑色，其兄弟结点有一个孩子不空，并且该孩子和兄弟结点不在同一边（右左或者左右的情况）</p>
<ol>
<li>先将兄弟结点和兄弟结点的儿子结点颜色互换</li>
<li>其他情况
<ol>
<li>如果兄弟结点是左子树，兄弟结点的儿子结点是右子树：对兄弟结点进行左旋</li>
<li>如果兄弟结点是右子树，兄弟结点的儿子结点是左子树：对兄弟结点进行右旋</li>
</ol>
</li>
<li>将后续变换按照第3条处理</li>
</ol>
</li>
<li>
<p>删除结点为黑色，其兄弟结点有两个孩子，兄弟结点为黑色而且两个孩子结点也为黑色：</p>
<ol>
<li>将父亲结点和兄弟结点颜色互换</li>
</ol>
</li>
<li>
<p>删除结点为黑色，其兄弟结点有两个孩子，而且兄弟结点为红色：</p>
<ol>
<li>将兄弟结点和父亲结点的颜色互换</li>
<li>其他情况
<ol>
<li>被删除的元素为左子树：对父亲结点左旋</li>
<li>被删除的元素为右子树：对父亲结点右旋</li>
<li>将后续变换按照第5条进行处理</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>剩下一个儿子：</p>
<ul>
<li>将儿子结点涂成黑色放到被删除结点的位置</li>
</ul>
<p>剩下两个儿子：</p>
<p>找到删除结点的右子树中最左的结点，两两值交换，然后删除结点的情况就变成了上面两种情况中的一种了</p>
<p>1.删除结点只有一个儿子的情况</p>
<p>2.删除结点没有儿子的情况</p>
<p>参考链接：
<a href="%E7%BA%A2%E9%BB%91%E6%A0%91">https://www.cnblogs.com/yinbiao/p/10732600.html</a>
<a href="%E5%B9%B3%E8%A1%A1%E6%A0%91">https://www.cnblogs.com/zhangbaochong/p/5164994.html</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/datastructure/">#DataStructure</a>,
            
        
        <time class="post-date" datetime="2021-07-13T14:29:30&#43;08:00">
            13 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/12/get-post/">操作系统(3)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="单处理器调度">单处理器调度</h3>
<ul>
<li>长程调度
<ul>
<li>新建</li>
<li>销毁</li>
</ul>
</li>
<li>中程调度
<ul>
<li>换入</li>
<li>换出</li>
</ul>
</li>
<li>短程调度
<ul>
<li>时钟中断</li>
<li>IO中断</li>
<li>系统调用</li>
<li>信号</li>
</ul>
</li>
</ul>
<p>长程调度决定了那个程序可以进入系统中被处理</p>
<p>进程越多，每个进程时间越少，调度代价越大。</p>
<p>短程调度算法</p>
<ul>
<li>周转时间</li>
<li>响应时间</li>
<li>最后期限</li>
<li>可预测性</li>
</ul>
<p>短程调度考虑性能指标</p>
<ul>
<li>吞吐量</li>
<li>处理器使用率</li>
</ul>
<p>考虑其他因素</p>
<ul>
<li>公平性</li>
<li>优先级</li>
<li>平衡资源</li>
</ul>
<p>优先级：每个进程有一个优先级，选择优先级高的进程。多个优先级，多个就绪队列，低优先级的有可能饥饿，因此优先级是动态改变的。</p>
<p>选择函数：确定在就绪进程中选择哪个进程在下一次执行</p>
<p>决策模式（Decision Mode）</p>
<ul>
<li>非抢占</li>
<li>抢占</li>
</ul>
<p>进程周转时间 = 结束 - 到达 = 等待 + 服务</p>
<p>归一化周转时间 = 周转时间 / 服务时间</p>
<p>调度算法：</p>
<ul>
<li>FCFS</li>
<li>轮转</li>
<li>SPN（最短优先）</li>
<li>SRT（最短剩余时间）</li>
<li>HRRN（最高响应比）</li>
</ul>
<h3 id="io管理与磁盘调度">IO管理与磁盘调度</h3>
<p>IO设备的三种类别</p>
<ul>
<li>人类可读</li>
<li>机器可读</li>
<li>通信设备</li>
</ul>
<p>三种IO通信技术</p>
<ul>
<li>可编程IO
<ul>
<li>I/O处理模块设置I/O状态寄存器中相应的位。处理器不断询问I/O模块的状态，严重降低了系统的性能。</li>
</ul>
</li>
<li>中断驱动IO
<ul>
<li>每个字的读写都需要通过处理器进行，消耗了大量的处理器时间。</li>
</ul>
</li>
<li>DMA
<ul>
<li>依托分离的DMA总线</li>
</ul>
</li>
</ul>
<p>操作系统的设计</p>
<p>IO Buffer</p>
<p>进程必须等待IO操作完成后继续执行</p>
<p>可能出现单进程死锁————进程在IO开始前被换出</p>
<p>面向块的缓冲</p>
<ul>
<li>一次传递一块</li>
<li>磁盘磁带</li>
</ul>
<p>面向流的IO</p>
<ul>
<li>字节流形式传递信息</li>
<li>打印机、鼠标</li>
</ul>
<p>OS给一个I/O请求分配一个位于主存中系统部分的缓冲区</p>
<p>面向块</p>
<ul>
<li>输入传送的数据被放到系统缓冲区中</li>
<li>传送完成时，进程把块移动到用户空间
进程请求另外一块</li>
<li>在下一块数据正在读取的时候，用户进程可以处理一块数据</li>
<li>可以换出进程</li>
<li>输入是发生在系统内存，而非用户内存</li>
</ul>
<p>面向流
每次传送一行或一个字节
一次一行：适用于滚动方式的终端，用户输入一行后回车。行式打印机。</p>
<p>使用两个系统缓冲区
一个进程往一个缓冲区中传送数据（或从这个缓冲区中取数据）的同时，OS正在清空（或者填充）另外一个缓冲区</p>
<p>多于两个的缓冲区
每个缓冲区是循环缓冲区中的单元
用于使得I/O操作跟上进程速度</p>
<p>缓冲是用来平滑I/O需求的峰值的一种技术，但当进程的平均需求大于I/O设备的服务能力时，缓冲再多也不能让I/O设备与这个进程一直并驾齐驱。</p>
<p>调度算法
先进先出FIFO
优先级PRI
后进先出LIFO
最短服务时间优先SSTF
SCAN
磁头臂仅仅沿一个方向移动，并在途中满足所有未完成的请求
到达最后一个磁道或该方向上没有其它请求，停止
反向移动
C-SCAN
循环SCAN
N-Step-SCAN
把队列分成长度为N的子队列，每次用SCAN扫描一子队列，在扫描期间，新请求必须加到其它队列中
FSCAN
分成两个子队列，开始时候，所有请求在一个队列中，扫描时，新请求入另外一个队列</p>
<p>RAID0 - RAID6</p>
<p>磁盘cache
基于频率决定</p>
<h3 id="文件管理">文件管理</h3>
<p>文件管理功能</p>
<ul>
<li>识别和定位文件</li>
<li>使用目录来描述所有文件的位置以及属性</li>
<li>在一个共享系统中描述用户权限控制</li>
<li>记录和块之间的映射组织</li>
<li>为文件分配空闲区块</li>
<li>管理空闲区块</li>
</ul>
<p>文件组织原则</p>
<ul>
<li>访问快速</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性</li>
</ul>
<p>五种基本的文件组织方式</p>
<ul>
<li>堆</li>
<li>顺序文件</li>
<li>索引顺序文件</li>
<li>索引文件</li>
<li>直接或散列文件</li>
</ul>
<p>文件分配方式</p>
<ul>
<li>连续</li>
<li>链式</li>
<li>索引</li>
</ul>
<p>空间管理</p>
<ul>
<li>磁盘分配表</li>
<li>位表</li>
<li>链式空闲区</li>
<li>索引</li>
<li>空闲块列表</li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/os/">#os</a>,
            
        
        <time class="post-date" datetime="2021-07-12T19:30:30&#43;08:00">
            12 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/12/get-post/">操作系统(2)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="进程与线程">进程与线程</h3>
<p>进程：</p>
<ul>
<li>资源所有权</li>
<li>调度/执行</li>
</ul>
<p>多线程OS：</p>
<p>支持在一个进程中执行多个线程的能力</p>
<p>资源分配和保护的单位</p>
<p>线程具有</p>
<ul>
<li>线程状态</li>
<li>线程上下文（寄存器，计数器）</li>
<li>执行栈</li>
<li>静态存储空间</li>
</ul>
<p>多线程的优点：</p>
<p>创建代价小，销毁代价小，切换代价小，通信代价小。</p>
<p>线程的基本操作：</p>
<ul>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ul>
<p>RPC：</p>
<ul>
<li>单线程</li>
<li>多线程</li>
</ul>
<p>纯用户级线程：</p>
<p>优点：</p>
<ul>
<li>不需要模式转换</li>
<li>调度算法是应用程序专用的</li>
<li>可以在任意OS中运行</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统调用引发线程组所有线程都被阻塞</li>
<li>无法利用多处理器技术</li>
</ul>
<p>纯内核级线程：</p>
<p>优点：</p>
<ul>
<li>内核可以调度同一个进程的多个线程再多个处理器上同时运行</li>
<li>线程阻塞不会引起同一进程内其余线程的阻塞</li>
<li>内核例程本身可以使用多线程</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程的大量模式切换</li>
</ul>
<p>组合方法
＝用户级线程＋内核级线程
线程在用户空间中创建
线程的调度和同步也在应用程序中进行</p>
<h3 id="内存管理">内存管理</h3>
<ul>
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织
<ul>
<li>模块可以单独编写和编译</li>
<li>可以执行模块级别的保护</li>
<li>可以在进程间共享模块</li>
</ul>
</li>
<li>物理组织</li>
</ul>
<p>内存分区</p>
<p>固定分区</p>
<ul>
<li>程序在一个分区中</li>
<li>OS负责交换分区</li>
<li>程序太大，程序员必须进行覆盖设计以使得程序能够装入一个分区内运行</li>
<li>内部碎片多，主存利用率低</li>
</ul>
<p>大小相等的分区：任意一块均可</p>
<p>大小不等的分区：</p>
<ul>
<li>最小适合算法
<ul>
<li>分区数目固定，内部碎片多</li>
</ul>
</li>
</ul>
<p>动态分区</p>
<ul>
<li>
<p>长度数目可变</p>
</li>
<li>
<p>允许分配给进程所需要的空间</p>
</li>
<li>
<p>外部碎片</p>
</li>
<li>
<p>压缩技术</p>
</li>
<li>
<p>最佳适配</p>
<ul>
<li>性能差</li>
<li>经常要压缩</li>
<li>碎片难以利用</li>
</ul>
</li>
<li>
<p>首次适配</p>
<ul>
<li>从开始扫描内存，选择第一块可用内存</li>
<li>速度最快</li>
<li>查找效率不高</li>
</ul>
</li>
<li>
<p>下一个适配</p>
<ul>
<li>最后经常有一个大块</li>
<li>大块被分成小块</li>
<li>需要压缩整理</li>
</ul>
</li>
<li>
<p>最差适配</p>
</li>
</ul>
<p>伙伴系统</p>
<ul>
<li>基于二的幂次和二进制</li>
</ul>
<p>重定向</p>
<ul>
<li>
<p>逻辑地址</p>
</li>
<li>
<p>相对地址</p>
</li>
<li>
<p>物理地址</p>
</li>
<li>
<p>基地址寄存器</p>
</li>
<li>
<p>边界寄存器</p>
</li>
<li>
<p>在进程加载、交换、压缩的时候设置</p>
</li>
</ul>
<p>内存分页技术</p>
<p>内存分帧，进程分页，页帧等大小。</p>
<p>OS为每个进程维护一个页表，维护页到帧的映射，此时内存地址 = 页号 + 偏移量。</p>
<p>内存分段技术</p>
<p>程序有个最大段长度
地址 = 段号 + 偏移量
维护段表</p>
<h3 id="虚拟内存技术">虚拟内存技术</h3>
<p>内存访问被动态地映射成物理地址
一个进程可能被分成多个块，这些块不需要加载在内存的连续地址空间中
在运行期间，一个进程的所有块不需要全部加载到内存</p>
<ul>
<li>OS将内存分解成给一系列供程序使用的块。</li>
<li>常驻集：进程执行中的任何时候都在主存中的部分</li>
<li>当访问一个不在内存中的地址时，产生一个中断</li>
<li>OS用块的形式来调度和管理进程</li>
</ul>
<p>如果一个内存块需要被其它进程使用，该块的进程内容就需要被交换出去。
处理器大部分的时间都用于交换块，而不是执行指令。</p>
<p>一个进程中的代码和数据的访问有集簇的倾向
因此，假设在很短时间内，仅需要访问进程的一部分块是合理的
对未来可能使用到的块进程预测 避免系统抖动 虚拟内存机制是合理的</p>
<p>每个进程有一个自己的页表</p>
<p><a href="F:%5CHugo%5Cblog%5Cstatic%5Cimages%5Cos%5Cpage-table.png">页表项</a></p>
<p>每个页表项包含进程的页、内存的帧、以及二者的对应关系
一个位用于表明该页是否在主存中
一个位用于表明该页是否被修改
其它项</p>
<p><a href="https://sonemiyuki.cn/images/os/memory-page.png">内存分页系统</a></p>
<p>页表很大的时候采用二级页表，只有部分页表在内存中。</p>
<p><a href="https://sonemiyuki.cn/images/os/2-level-pages.png">二级页表</a></p>
<p>反向页表：</p>
<p>虚拟地址的页被hash之后指向反向页表
每个物理内存帧对应一个反向列表帧</p>
<p>访问内存的时间问题：用cache解决</p>
<p>先查TLB，如果没有就去查页表，如果在主存就更新TLB，不然就访问二级存储把页取出来</p>
<p>分段类似</p>
<p>段页式：一个段表，多个页表</p>
<p>读取内存策略：</p>
<ul>
<li>请求式分页
<ul>
<li>不请不取</li>
</ul>
</li>
<li>预约式分页
<ul>
<li>取进程的连续页</li>
</ul>
</li>
</ul>
<p>换页策略：</p>
<p>帧有个lock位锁定不会被替换，如OS内核，重要控制结构，IO缓冲区等。</p>
<ul>
<li>OPT</li>
<li>LRU</li>
<li>FIFO</li>
<li>Clock</li>
</ul>
<p>更强的时钟算法：</p>
<p>使用位 + 修改位</p>
<ul>
<li>查找第一个u = 0; m = 0的帧</li>
<li>查找第一个u = 0, m = 1的帧</li>
<li>没找到，u均改为0，转到第一步</li>
</ul>
<p>驻留集合管理</p>
<p>研究的是给进程分配多大的内存空间</p>
<ul>
<li>固定分配策略</li>
<li>可变分配策略</li>
<li>窗口越大错误率与越小</li>
</ul>
<p>清除策略</p>
<ul>
<li>请求式清除</li>
<li>预约式清除</li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/os/">#os</a>,
            
        
        <time class="post-date" datetime="2021-07-12T19:29:30&#43;08:00">
            12 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/12/java/">Java集合类数据结构</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="collection">Collection</h3>
<p><img src="https://sonemiyuki.cn/images/java/Collections.png" alt="Collections"></p>
<p>Collection提供了一系列接口给集合实现。</p>
<h3 id="iterator">Iterator</h3>
<p>Iterator：用于遍历集合的对象，本身是同名设计模式的体现。</p>
<h3 id="abstractlist">AbstractList</h3>
<p>AbstractList的算法是基于内部Iterator遍历实现的，用一个cursor和size()函数控制迭代的数量</p>
<h3 id="spliterator">Spliterator</h3>
<p>Spliterator是Java 8中加入的一个新接口；这个名字代表“可拆分迭代器”（splitable iterator）。和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。集合实现了Spliterator接口，接口提供了一个spliterator方法。</p>
<p>Spliterator可以单独遍历元素（tryAdvance()）或批量顺序遍历元素（forEachRemaining()）。Spliterator还可以将它的一些元素（使用trySplit()）进行分区作为另一个Spliterator，以用于可能并行的操作。使用无法拆分的Spliterator或以高度不平衡或低效的方式进行操作不太可能从并行性中受益。遍历和拆分至用完元素;每个Spliterator仅对单个批量计算有用。</p>
<p>这个就是用来多线程并行迭代的迭代器，这个迭代器的主要作用就是把集合分成了好几段，每个线程执行一段，因此是线程安全的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">//如果存在剩余元素，则对其执行给定操作，返回true；否则返回false。如果此Spliterator为ORDERED，则会对遇见顺序中的下一个元素执行操作。操作抛出的异常会转发给调用者。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAdvance</span><span style="color:#f92672">(</span>Consumer<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">&gt;</span> action<span style="color:#f92672">);</span>
 
<span style="color:#75715e">//按顺序对每个剩余元素执行给定操作，直到所有元素都已处理或操作抛出异常为止。如果此Spliterator为ORDERED，则会按遇见顺序执行操作。操作抛出的异常会转发给调用者。默认方法调用tryAdvance方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">forEachRemaining</span><span style="color:#f92672">(</span>Consumer<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">&gt;</span> action<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span> <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>tryAdvance<span style="color:#f92672">(</span>action<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
 
<span style="color:#75715e">//对任务分割，返回一个新的Spliterator迭代器
</span><span style="color:#75715e"></span>Spliterator<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">trySplit</span><span style="color:#f92672">();</span>
 
<span style="color:#75715e">//用于估算还剩下多少个元素需要遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">estimateSize</span><span style="color:#f92672">();</span>
 
<span style="color:#75715e">//当迭代器拥有SIZED特征时，返回剩余元素个数；否则返回-1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">getExactSizeIfKnown</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>characteristics<span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> SIZED<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">?</span> <span style="color:#f92672">-</span>1L <span style="color:#f92672">:</span> estimateSize<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
 
 <span style="color:#75715e">//返回当前对象有哪些特征值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">characteristics</span><span style="color:#f92672">();</span>
 
<span style="color:#75715e">//是否具有当前特征值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasCharacteristics</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> characteristics<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
   <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>characteristics<span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> characteristics<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> characteristics<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">//如果Spliterator的list是通过Comparator排序的，则返回Comparator
</span><span style="color:#75715e">//如果Spliterator的list是自然排序的 ，则返回null
</span><span style="color:#75715e">//其他情况下抛错
</span><span style="color:#75715e"></span><span style="color:#66d9ef">default</span> Comparator<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getComparator</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>注解：</p>
<ol>
<li>trySplit:一般使用二分法，修改自身index为mid，然后传下去。</li>
<li>characteristics()：Spliterator接口中定义的一些集合的特征</li>
<li>spliterator特征值附表：</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ORDERED</td>
<td>元素定义了遇见顺序，这使得拆分，下一个和遍历剩余有一个前缀顺序，没有保证基于散列的集合（如HashSet）的顺序</td>
</tr>
<tr>
<td>DISTINCT</td>
<td>每对遇到的元素x，y，!x.equals(y)</td>
</tr>
<tr>
<td>SORTED</td>
<td>在ORDERED基础上，遇见顺序遵循定义的排序顺序，此时getComparator()返回关联的Comparator，如果所有元素都是Comparable并按其自然顺序排序，则返回null。</td>
</tr>
<tr>
<td>SIZED</td>
<td>在遍历或拆分之前从estimateSize()返回的值表示有限大小</td>
</tr>
<tr>
<td>NONNULL</td>
<td>保证遇见的元素非空</td>
</tr>
<tr>
<td>IMMUTABLE</td>
<td>不能进行结构修改</td>
</tr>
<tr>
<td>CONCURRENT</td>
<td>多线程下安全Spliterator应该有一个关于遍历期间修改影响的记录策略</td>
</tr>
<tr>
<td>SUBSIZED</td>
<td>能够知道子结构的大小，因为一些树型结构不容易知道字子结构的大小</td>
</tr>
</tbody>
</table>
<p>Collections:</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>阈值</th>
<th>低算法</th>
<th>高算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>搜索</td>
<td>5000或支持随机存取</td>
<td>基于新的二分查找</td>
<td>基于迭代器的二分查找</td>
</tr>
<tr>
<td>逆转</td>
<td>18或者支持随机存取</td>
<td>直接交换</td>
<td>基于迭代器的交换</td>
</tr>
<tr>
<td>洗牌</td>
<td>5或支持随机存取</td>
<td>直接洗牌</td>
<td>基于迭代器洗牌</td>
</tr>
<tr>
<td>填充</td>
<td>25或者支持随机存取</td>
<td>直接set</td>
<td>基于迭代器进行存储</td>
</tr>
<tr>
<td>拷贝</td>
<td>10或者支持随机存取</td>
<td>直接set</td>
<td>基于迭代器的set</td>
</tr>
<tr>
<td>切片-连接</td>
<td>100或者支持随机存取</td>
<td>直接set</td>
<td>三次反转算法</td>
</tr>
<tr>
<td>替代全部算法</td>
<td>11或支持随机存取</td>
<td>直接set</td>
<td>基于迭代器的set</td>
</tr>
<tr>
<td>子序列坐标（从前往后或从后往前）</td>
<td>35或者支持随机存取</td>
<td>基于普通的set</td>
<td>基于迭代器的set</td>
</tr>
</tbody>
</table>
<h3 id="vector">Vector</h3>
<p>方法是synchonized，比较安全。</p>
<p>Vector原始容量是10
需要多少扩多少，默认翻倍</p>
<h3 id="stack">Stack</h3>
<p>基于Vector派生，所有的操作都需要synchronized</p>
<h3 id="arraylist">ArrayList</h3>
<p>默认容量10
底层data基于数组</p>
<p>获取迭代器时会将 expectedModCount 赋值为 modCount， 若在使用迭代器迭代期间修改列表则会导致两者不相等，调用next()时会进行checkForComodification检查抛异常。说明迭代时不可以进行修改操作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#75715e">//保证空间
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span>
<span style="color:#75715e">//grow()进行扩容
</span><span style="color:#75715e">//grow使其容量增长
</span><span style="color:#75715e">//newCapacity(minCapacity)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">newCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span>
<span style="color:#75715e">//初始化的时候扩到max(10, 最小容量)
</span><span style="color:#75715e">//新容量&lt;最小容量的时候直接扩到最小容量
</span><span style="color:#75715e">//未超过maxarraysize就1.5倍扩张
</span><span style="color:#75715e">//MAX_ARRAY_SIZE = MAX_INT - 8
</span><span style="color:#75715e">//超过maxarraysize就扩容成maxin
</span></code></pre></div><p>维护一个信号量，所有潜在的引起并发问题的crud都要走modcount，修改前获取modcount，然后对其进行操作，操作之后比较modcount，然后对modcount++表示当前操作进行处理</p>
<h3 id="abstract-sequencial-list">Abstract Sequencial List</h3>
<p>将一些crud操作改造为走迭代器的模式</p>
<h3 id="linkedlist">LinkedList</h3>
<p>Node数据结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
   E item<span style="color:#f92672">;</span>
   Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>
   Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> prev<span style="color:#f92672">;</span>

   Node<span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> prev<span style="color:#f92672">,</span> E element<span style="color:#f92672">,</span> Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">item</span> <span style="color:#f92672">=</span> element<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> prev<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="hashmap">HashMap</h3>
<p>默认容量16
最大容量2^30
改树阈值8
改链阈值6</p>
<p>本质上是基于Java链表的一个实现。</p>
<p>基于2的幂次扩容</p>
<h3 id="hashmap重要">HashMap重要</h3>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_30711091/article/details/88847892">Java集合类</a>
<a href="https://blog.csdn.net/sl1992/article/details/100149187">Spliterator 1</a>
<a href="https://www.cnblogs.com/nevermorewang/p/9368431.html">Spliterator 2</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-12T16:29:30&#43;08:00">
            12 Jul 2021
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 4</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/post/page/2/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">世界的中心</a> All rights reserved - 2021-</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/index.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.min.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.js"></script>  

</body>
</html>

