<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Posts &middot;  世界的中心" />
  	<meta property="og:site_name" content="世界的中心" />
  	<meta property="og:url" content="https://sonemiyuki.cn/post/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Posts &middot;  世界的中心
  </title>

    <meta name="description" content="教学楼的天台，是世界的中心。" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://sonemiyuki.cn/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://sonemiyuki.cn/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://sonemiyuki.cn/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://sonemiyuki.cn/index.xml" rel="alternate" type="application/rss+xml" title="世界的中心" />
      
      
        <link href="https://sonemiyuki.cn/post/index.xml" rel="alternate" type="application/rss+xml" title="Posts &middot; 世界的中心" />
      
    
    <meta name="generator" content="Hugo 0.83.0" />

    <link rel="canonical" href="https://sonemiyuki.cn/post/" />

     
</head>
<body class="nav-closed">
<div id="particles-js"></div>
  


 <div class="site-wrapper">




	<header class="main-header" style="background-image: url(https://sonemiyuki.cn/images/user.jpg)">

    <nav class="main-nav overlay clearfix">
      
        <a class="blog-logo" href="https://sonemiyuki.cn/"><img src="https://sonemiyuki.cn/images/user.png" alt="Home" /></a>
      
      
        
          <a class="menu-button icon-feed" href="https://sonemiyuki.cn/post/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">世界的中心</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    
    
    
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 3</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/post/page/2/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/network/">计算机网络面经与常见QA（2）</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <ol start="11">
<li><strong>各层的报文格式</strong></li>
</ol>
<ul>
<li>以太网帧
<ul>
<li>目标MAC地址（6B）</li>
<li>源MAC地址（6B）</li>
<li>类型（2B）</li>
<li>数据（46-1500B）</li>
<li>FCS（4B）</li>
</ul>
</li>
<li>IP数据报
<ul>
<li>版本（4bit）</li>
<li>header长度（4bit），以32bit为单位</li>
<li>服务类型（8bit）</li>
<li>总长度（16bit）</li>
<li>上层协议标识（16bit）标记上层协议</li>
<li>标志：（3bit）用来表示是否有分片，是否允许分片等</li>
<li>片偏移量（13bit）以8bit为单位的片偏移量</li>
<li>生存时间（8bit）跳数限制，若TTL为0，则丢弃这个数据包</li>
<li>协议（8bit）</li>
<li>校验和（16bit）检验首部的校验和</li>
<li>源地址（32bit）</li>
<li>目的地址（32bit）</li>
</ul>
</li>
<li>UDP数据报
<ul>
<li>源端口（16bit）</li>
<li>目的端口（16bit）</li>
<li>UDP长度（16bit）</li>
<li>UDP校验和（16bit）</li>
<li>伪首部：前缀源IP（4B），目的IP（4B），0（1B），17（1B），UPD长度（2B），以16个bit为单位，按位加法，然后取反。</li>
</ul>
</li>
<li>TCP数据报
<ul>
<li>源端口（16bit）</li>
<li>目的端口（16bit）</li>
<li>数据序号seq（16bit）</li>
<li>确认序号ack（16bit）</li>
<li>偏移量（4bit）</li>
<li>保留（6bit）</li>
<li>六个标志位（6bit）
<ul>
<li>URG：紧急指针字段有效，尽快传输</li>
<li>ACK：设定ack字段有效</li>
<li>PSH：尽快将保温传给应用层</li>
<li>RST：要求重建TCP</li>
<li>SYN：设定syn字段有效</li>
<li>fin：表示传输结束，请求释放连接</li>
</ul>
</li>
<li>窗口字段（16bit）</li>
<li>校验和（16bit）</li>
<li>紧急指针（16bit）</li>
</ul>
</li>
</ul>
<ol start="12">
<li>
<p><strong>建立TCP/UDP连接的调用</strong>
<img src="https://sonemiyuki.cn/images/socketprocess.png" alt="TCP/UDP过程"></p>
</li>
<li>
<p><strong>路由协议</strong></p>
</li>
</ol>
<ul>
<li><strong>RIP(Routing Information Protocol)路由信息协议</strong>
<ul>
<li>距离向量型的一种路由协议</li>
<li>30s一次,对全网广播,等待5次,将已知路由进行广播,然后下一跳继续广播,进行逐步传播</li>
</ul>
</li>
<li><strong>OSPF(Open Shortest Path First)开放最短路径优先</strong>
<ul>
<li>基于IP</li>
<li>适用泛洪法发送请求</li>
<li>发送信息是路由器临近的所有路由器的链路状态</li>
<li>链路状态变化才发送信息</li>
<li>Dijkstra</li>
<li>收敛快</li>
<li>划分自治系统</li>
<li>问候、数据库描述、链路状态请求、链路状态更新、链路状态确认</li>
</ul>
</li>
<li><strong>BGP(Border Gateway Protrol)边界网关协议</strong>
<ul>
<li>寻求一条能到达目的地并且比较好的路由</li>
<li>BGP发言人</li>
</ul>
</li>
</ul>
<ol start="14">
<li><strong>等待2MSL的原因</strong></li>
</ol>
<ul>
<li>保证客户端发送的最后一个ACK报文能够到达服务器。</li>
<li>新的连接中不会出现旧连接的请求报文。</li>
</ul>
<ol start="15">
<li><strong>TCP的可靠性</strong></li>
</ol>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传
<ul>
<li>超时重传基于两个可能的原因
<ul>
<li>发送过去的包全体丢包,接到这个包之后接收方没有收到</li>
<li>接受的ACK报文丢包,接收方发现数据存在,仍然发送ACK应答</li>
</ul>
</li>
<li>动态计算最大超时时间</li>
</ul>
</li>
<li>连接管理
<ul>
<li>三次握手,四次挥手确保可靠的连接</li>
</ul>
</li>
<li>流量管理
<ul>
<li>滑动窗口大小的内容实际上是接收端数据缓冲区的剩余大小。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送<strong>窗口探测</strong>数据段，让接收端把窗口大小告诉发送端。</li>
</ul>
</li>
<li>拥塞控制
<ul>
<li>慢启动:少量数据探路,拥塞窗口指数增长</li>
<li>增长过阈值之后线性增长</li>
<li>拥塞之后慢启动的阈值变为原来的一半,拥塞窗口重置为 1</li>
</ul>
</li>
</ul>
<ol start="16">
<li><strong>糊涂窗口综合征</strong></li>
</ol>
<ul>
<li>
<p>当TCP中发送端发送数据很慢或者接收端接收缓冲数据很慢,就会使得应用进程的有效载荷很小。</p>
</li>
<li>
<p>发送端：利用算法强迫TCP收集一定数据为更大的数据块再发送，Nagle算法决定TCP的等待时延</p>
</li>
<li>
<p>接收端：</p>
<ul>
<li>Clark解决方法 Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</li>
<li>延迟确认 第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到入缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种症状。</li>
</ul>
</li>
<li>
<p><a href="https://www.cnblogs.com/mawanglin2008/articles/3607767.html">参考链接1-FTP的主动模式和被动模式</a></p>
</li>
<li>
<p><a href="https://www.nowcoder.com/discuss/1937">参考链接2-面经</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/chpdirector84/article/details/6033511">参考链接3-RARP</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_30852577/article/details/79009060">参考链接4-路由协议</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">参考链接5-TCP面经</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157">参考链接6-TCP/IP</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/ggjucheng/archive/2012/02/03/2337046.html">参考链接7-糊涂窗口综合征</a></p>
</li>
</ul>
<p>参考书目：
《计算机网络（第7版）》谢希仁</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/http/">#http</a>,
            
                <a href="https://sonemiyuki.cn/tags/%E7%BD%91%E7%BB%9C/">#网络</a>,
            
        
        <time class="post-date" datetime="2021-07-11T23:41:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/java/">Java面经后端</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            
          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/java/">Java面经基础（含OO）</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="oo的优点和三个特性">OO的优点和三个特性</h3>
<p>优点：基于面向过程，易于复用，易于理解，可扩展，可维护</p>
<ul>
<li>封装
<ul>
<li>外部不关心也无法修改内部实现</li>
</ul>
</li>
<li>继承
<ul>
<li>继承基类的方法并做出改变</li>
</ul>
</li>
<li>多态
<ul>
<li>同一个方法，不同的实现</li>
</ul>
</li>
</ul>
<h3 id="java编译过程">Java编译过程</h3>
<ol>
<li>编译：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。
编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的字面量（文本字符串、八种基本类型的值、被声明为final的常量等）以及符号引用（类和方法的全限定名、字段的名称和描述符、方法的名称和描述符）方法字节码中放的是各个方法的字节码（依赖操作数栈和局部变量表，由JVM解释执行）</li>
<li>经过JVM的解释运行
加载 &ndash;&gt; 验证 &ndash;&gt; 准备 &ndash;&gt; 解析 &ndash;&gt; 初始化（其中验证、准备、解析统称为类的连接）</li>
</ol>
<h3 id="jdk-jvm-jre">JDK JVM JRE</h3>
<p>注意JRE包含bin和lib，bin是JVM虚拟机，lib是映射到不同操作系统所需要的库。</p>
<h3 id="-和-equals">== 和 equals</h3>
<p>== 比较的是栈里面的值，基础数据类型比较基础数据类型，对象比较地址</p>
<p>equals默认用==进行比较
String的equals重写将另一个对象强转String</p>
<h3 id="final">final</h3>
<p>final的作用</p>
<ul>
<li>修饰类：类不能被继承</li>
<li>修饰方法：可以重载不能重写</li>
<li>修饰变量：常变量，不能更改值</li>
<li>修饰类变量：声明，非静态初始化块，构造器</li>
<li>类变量：静态初始化块，声明</li>
<li>作用在栈上，基础变量不能改，引用的值可变</li>
</ul>
<h3 id="为什么局部内部类和匿名内部类只能访问局部final类型的变量">为什么局部内部类和匿名内部类只能访问局部final类型的变量</h3>
<p>编译生成class文件，内部类的class文件会独立出来。外部类方法结束局部变量销毁，但是内部类如果还在执行就会出问题。将局部变量复制作为内部类的成员变量，延长其生命周期。</p>
<p>final是某种保持一致性的妥协</p>
<h3 id="重载和重写">重载和重写</h3>
<p>重载： 同一个类、方法名相同，参数名（类型、个数、顺序）不同，返回值修饰符可以不同；</p>
<p>重写：父子类中，方法名参数名必须相同，返回值范围和抛出异常值范围小于等于父类，修饰符范围大于等于父类，无法重写父类private方法。</p>
<h3 id="接口和抽象类">接口和抽象类</h3>
<ul>
<li>抽象类可以有普通成员函数，接口的方法必须全部抽象</li>
<li>抽象类成员变量类型比较宽，看接口的成员变量必须是public static final</li>
<li>抽象类单继承，可以通过接口实现多继承</li>
</ul>
<p>接口：对类的行为进行约束，约定了一定要有某个方法。like-a。</p>
<p>抽象类设计的本质是代码复用。需要不同的类具有某种相同的行为，还需要这些类的这些方法实现方法一致。is-a。</p>
<p>关注事物的本质用抽象类，关注某些操作用接口。</p>
<p>定义抽象类的代价比较高，定义接口可以降低设计难度。</p>
<p>抽象类被应用于模板方法中。</p>
<h2 id="hashcode-和-equals">hashCode 和 equals</h2>
<p>hashCode:获取哈希值，或者说将其map到int的范围内。</p>
<p>对象加入HashSet的时候，HashSet会先计算对象的HashCode判断对象加入的位置，看该位置是否还有值，若无，java假设对象没有重复出现，如果发现有，调用equals检查是否相同。核心在减少equals的次数</p>
<p>参考链接：
<a href="https://blog.csdn.net/super_YC/article/details/71439786">java 程序编译和运行过程详解</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/java/">Java面经集合</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h3 id="stringstringbuilderstringbuffer">String、StringBuilder、StringBuffer</h3>
<p>String：final修饰，不可变，每次操作产生新对象，浪费时间空间</p>
<p>StringBuffer和StringBuilder在原对象进行操作。StringBuffer的所有方法都是synchronize方法修饰的。</p>
<p>性能 Builder &gt; Buffer &gt; String</p>
<p>场景：改变字符串内容
优先StringBuilder，多线程使用StringBuffer。</p>
<h3 id="list-和-set">List 和 Set</h3>
<p>List： 有序，可重复，允许多个null，可以用迭代器也可以用get方法访问元素</p>
<p>Set：无序，不可重复，最多允许一个null，只能用迭代器遍历。</p>
<p>HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的<strong>Map对象的key</strong>，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p>
<h3 id="arraylist-和-linkedlist">ArrayList 和 LinkedList</h3>
<p>ArrayList：本质上基于数组，适合下标访问，具有1.5倍扩容机制，尾插法移动少，性能提高好。</p>
<p>LinkedList：本质上基于链表时适合插入删除，不适合查询，必须用iterator遍历，否则时间复杂度过大。indexOf会遍历整个链表。</p>
<h3 id="hashmap-和-hashtable">HashMap 和 HashTable</h3>
<p>HashTable线程安全，所有方法synchronized修饰。HashMap允许null的key和value。</p>
<p>底层实现：数组+链表
数组：二次hash之后映射到一个数组上面那如果未冲突则直接存Node进去，如果冲突，equals判断，相同则取代钙元素，否则判断链表高度，链表高度达到8转为红黑树，低于6则转回链表。</p>
<h3 id="hashmap扩容">HashMap扩容</h3>
<p>capacity 即容量，默认16。loadFactor 加载因子，默认是0.75threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。</p>
<p>当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。</p>
<p>HashMap的容量变化通常存在以下几种情况：
空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数设置赋值给阈值（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 阈值 = 容量 * 负载因子 。（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。（容量和阈值都变为原来的2倍时，负载因子还是不变）</p>
<p>由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在原位置，要么在原长度+原位置的位置。数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标确定。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“原长度+原坐标”。在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。</p>
<p>参考链接：
<a href="https://blog.csdn.net/prairie97/article/details/78481493">java中Map和Set的底层分析</a>
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap扩容机制</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/java/">#Java</a>,
            
        
        <time class="post-date" datetime="2021-07-11T22:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

	
	   
<article class="post post">
    <header class="post-header">
        <h2 class="post-title"><a href="https://sonemiyuki.cn/post/2021/07/11/get-post/">Jmeter(1)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h4 id="jmeter">Jmeter</h4>
<p>Jmeter脚本生成</p>
<ul>
<li>借助第三方工具录制
<ul>
<li>badboy 被淘汰</li>
<li>blazemeter 大陆无法注册账号</li>
</ul>
</li>
<li>使用自带的http代理服务器方式生成
<ul>
<li>添加线程&ndash;线程组</li>
<li>添加配置元件&ndash;cookie管理器</li>
<li>添加非测试元件&ndash;http代理服务器</li>
<li>配置http代理服务器并启动
<ul>
<li>端口：用户指定，和服务器无关</li>
<li>目标控制器：</li>
<li>Type：有时候需要选Java</li>
</ul>
</li>
<li>在客户端进行设置，使客户端请求通过代理。
<ul>
<li>Internet选项-连接-局域网设置</li>
</ul>
</li>
</ul>
</li>
<li>抓包手写</li>
</ul>
<p>Jmeter代理服务器</p>
<ul>
<li>转发</li>
<li>翻译</li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://sonemiyuki.cn/images/user.png" alt="Author image" nopin="nopin" />
        
        
            miyuki
        
        on
            
                <a href="https://sonemiyuki.cn/tags/jmeter/">#Jmeter</a>,
            
                <a href="https://sonemiyuki.cn/tags/http/">#http</a>,
            
                <a href="https://sonemiyuki.cn/tags/tester/">#tester</a>,
            
        
        <time class="post-date" datetime="2021-07-11T11:29:30&#43;08:00">
            11 Jul 2021
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 3</span>
	
	    <a class="older-posts" href="https://sonemiyuki.cn/post/page/2/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">世界的中心</a> All rights reserved - 2021-</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://sonemiyuki.cn/js/index.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.min.js"></script>
    <script src="https://sonemiyuki.cn/js/particles.js"></script>  

</body>
</html>

